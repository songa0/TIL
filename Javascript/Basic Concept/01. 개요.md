## 미리보기
 1. 자바스크립트의 특징  
   - 인터프리터 언어이다. (한 줄마다 기계어로 번역하여 실행함)  
   - 프로토타입 기반 객체지향 언어이다.  
   - 변수 타입이 없어 실행 도중에 데이터 타입이 동적으로 바뀔 수 있다.  
   - 함수도 객체이다. (이유는 [8강](https://github.com/songa0/TIL/blob/main/Javascript/Basic%20Concept/Chapter8.md#88-%EA%B0%9D%EC%B2%B4%EB%A1%9C%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98)에서 설명)  
 
 2. 호이스팅  
    호이스팅이란? 함수 안에 있는 선언들을 모두 끌어올려 함수 유효 범위의 최상단에 선언하는 것  
    참고한 URL : https://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.html
    
  3. 데이터 타입  
     자바스크립트의 데이터 타입은 크게 원시타입과 참조타입으로 나뉜다.  
     원시 타입은 값이 담긴 주소값을 바로 복제하는 반면 참조 타입은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다.
     (자세한 내용은 [더 나아가기](https://github.com/songa0/TIL/blob/main/Javascript/Basic%20Concept/01.%20%EA%B0%9C%EC%9A%94.md#35-%EB%8D%94-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)를 참고하자.)  
   
   4. Symbol   
      ECMAScript 6부터 새롭게 추가된 원시 값으로 자기 자신을 제외한 그 어떤 값과도 다른 유일무이한 값이다.
   
---------------------------------------------------------------------------------------------------------



<!--20201219 기록 시작-->
## 1. 자바스크립트의 개요
### 1.1 프로그래밍 언어
 컴퓨터 프로그램을 작성하기 위한 언어. 소프트웨어의 동작을 설명하기 위한 언어.  
 사람이 프로그래밍 언어를 사용하여 프로그램을 작성하면, 작성된 프로그램이 기계어로 번역되어 컴퓨터가 실행함.  
 (사람이 기계어를 이해하기 어렵기 때문에 프로그래밍 언어를 사용함)
 
### 1.2 컴파일 언어와 인터프리터 언어
 컴파일 : 소스코드를 기계어로 번역하는 행위  
 컴파일러 : 컴파일을 수행하는 소프트웨어  
 특징 : 컴파일하는데 시간이 걸리지만, 실행되는 속도가 빠름.  
 대표적인 언어 : C, C++, Java 등
 
 인터프리터 언어 : 한 줄마다 기계어로 번역하여 실행하는 프로그래밍 언어  
 인터프리터 : 프로그램을 번역해서 실행시키는 소프트웨어  
 특징 : 프로그램을 바로 실행할 수 있고, 수정했을 경우 바로 확인해 볼 수 있음. 한 줄마다 번역하며 실행하기 때문에 컴파일 언어보다 속도가 느림.  
 대표적인 언어 : Perl, Ruby, Python 등  
 
### 1.3 자바스트립트의 특징
 - 인터프리터 언어  
  : 실행 속도가 느릴 것 같지만, 최근 웹브라우저 대부분에 JIT 컴파일러가 내장되어 실행 속도가 빨라졌음.  
    \*참고  
     JIT 컴파일러란? 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법  
                    실행 시점에 인터프리트 방식으로 기계어 코드를 생성하면서, 그 코드를 캐싱하여 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.  
 - 프로토타입 기반 객체 지향 언어  
 - 동적 타입 언어  
  : 변수 타입이 없어 프로그램 실행 도중에 데이터 타입이 동적으로 바뀔 수 있음. 
  - 함수가 일급 객체이다.  
  : 함수는 객체이며, 함수에 함수를 인수로 넘길 수 있음.  
  - 함수가 클로저를 정의한다.
    - 클로저란? 내부 함수가 외부 함수의 맥락(Context)에 접근할 수 있음. (출처 : 생활코딩)  
 
## 2. 설치
 
## 3. 변수
### 3.1 변수 선언 생략
  var 문으로 선언하지 않은 변수 값을 읽으려고 하면 참조 오류가 발생한다.  
  ```javascript
  console.log(x); // ->ReferenceError: x is not defined  
  ```
  
  하지만 var 문으로 선언하지 않은 변수에 값을 대입할 때는 오류가 발생하지 않는다.  
  
  ```javascript
  x = 2;  
  console.log(x); //2  
  ```
  자바스크립트 엔진이 그 변수를 자동으로 **전역 변수**로 선언하기 때문. (하지만 Strict 모드를 활용하면 오류가 발생함.)
  
  
  ### 3.2 호이스팅
  호이스팅 : 함수 안에 있는 선언들을 모두 끌어 올려서 함수 유효 범위(함수 블록 안에서)의 최상단에 정의하는 것    
  참고한 URL : https://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.html   
  
  <!--20201219 기록 끝
      Node.js 를 공부하다보니, javascript 개념을 몰라서 이해를 못하는 부분이 많이 생겼다.
      그래서 오늘은 javascript를 공부했다. 마음 급하게 생각하지 않고, 꾸준히 공부해야겠다.-->
 
 <!--20201220 기록 시작-->
 
 ### 3.3 데이터 타입의 분류
 데이터 타입은 크게 원시 타입과 객체 타입으로 나눌 수 있음.
 원시 타입은 값이 담긴 주소값을 바로 복제하는 반면 참조 타입은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제함.  
 <table>
 <tr>
  <td rowspan = "6">데이터 타입</td>
  <td rowspan = "5">원시 타입</td>
  <td>숫자</td>
 </tr>
 <tr>
  <td>문자열</td>
 </tr>
 <tr>
  <td>논리값</td>
 </tr>
  <tr>
  <td>특수한 값(undefined, null)</td>
 </tr>
  <tr>
  <td>심벌</td>
 </tr>
  <tr>
  <td colspan = "2">객체 타입(참조 타입)</td>
 </tr>
 </table>

- 숫자 : 모두 64비트(8바이트) 부동소수점으로 표현 (java의 double형에 해당)    
- 문자열 : 길이가 16비트인 유니코드 문자를 나열한 것  
- 논리값 : true, false  
- 특수한 값 : 값이 없음을 표현하는 값에는 null, undefined가 있음  
 - null : 아무것도 없음을 표현함. 예를 들어 무언가를 검색했는데 검색 결과가 없을 때를 나타내는 값  
 - undefined   
  : 값을 아직 할당하지 않은 변수의 값  
  : 없는 객체의 프로퍼티를 읽으려고 했을 때의 값  
  : 없는 배열의 요소를 읽으려고 했을 때의 값  
  : 아무것도 반환하지 않는 함수가 반환하는 값  
  : 함수를 호출했을 때 전달받지 못한 인수의 값  
  
### 3.4 심벌
ECMAScript 6부터 새롭게 추가된 원시 값. 자기 자신을 제외한 그 어떤 값과도 다른 유일무이한 값.

- 심벌 생성  
  Symbol()을 사용하여 생성함.
  호출할 때마다 새로운 값을 만듦.
  
  ```javascript
  var s1 = Symbol();
  var s2 = Symbol();
  
  console.log(s1==s2); //false
  ```
  Symbol()에 인수를 전달하면 실벌의 설명을 덧붙일 수 있음. 심벌의 설명은 toString() 메서드를 사용해서 확인 가능함.
  
  ```javascript
  var cat = Symbol('cat');
  console.log(cat.toString()); // Symbol(cat)
  ```
- 심벌과 문자열 연결  
  ```javascipt
  var s1 = Symbol.for('cat'); //전역 레지스트리에 심벌이 만들어짐.
  var s2 = Symbol.for('cat'); 
  
  console.log(s1==s2)//true
  console.log(Symbol.keyFor(s1)); //cat -> 심벌과 연결된 문자열은 keyFor 함수를 사용하여 구할 수 있음.
  
  ```
<!--20210202 기록 시작-->
### 3.5 더 나아가기
  - 변수 선언과 데이터 할당  
   ```javascript
    var a = 'abc';
   ```
   위 문장으로 실행되는 데이터 할당의 흐름에 대해 알아보자  
   <table>
    <tr>
     <th rowspan = "2"> 변수 영역</th>
     <th>주소</th>
     <td>...</td>
     <td>1003</td>
     <td>1004</td>
    </tr>
    <tr>
     <th>데이터</th>
     <td></td>
     <td>이름 : a 값: @5004</td>
     <td></td>
    </tr>
     <tr>
     <th rowspan ="2">데이터 영역</th>
     <th>주소</th>
     <td>...</td>
     <td>5003</td>
     <td>5004</td>
    </tr>
    <tr>
     <th>데이터</th>
     <td></td>
     <td></td>
     <td>'abc'</td>
    </tr>
  </table>
 
   1. 변수 영역에서 빈 공간(@1003)을 확보한다    
   2. 확보한 공간의 식별자를 a로 지정한다    
   3. 데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장한다  
   4. 변수 영역에서 a라는 식별자를 검색한다. (@1003)  
   5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다    
 
   왜 변수 영역에 값을 직접 대입하지 않고, 한 단계를 더 거치는 것일까?  
    : 데이터 변환을 자유롭게 할 수 있게하고 동시에 메모리를 더욱 효율적으로 관리하기 위함이다.  
      만약 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 다시 저장하기 위해서는 확보된 공간을 데이터 크기에 맞게 늘리는 작업이 선행되어야 한다.  
      해당 공간이 메모리 상의 가장 마지막에 있었다면 뒤쪽으로 늘리기만 하면 되지만, 중간에 있다면 뒤에 저장된 데이터들을 전부 옮겨야한다.  
      결국 효율적으로 문자열 데이터의 변환을 처리하기 위해서는 변수와 데이터를 별도의 공간에 저장하는 것이 최적이다.  
 <!--20210202 기록 마침 변수에 값이 할당될 때 메모리 단에서의 흐름에 대해 알게되었고, 변수에 값을 직접 대입하지 않는 이유에 대해서도 알게되었다.-->
 <!--20210208 기록 시작-->
 
  - 불변값  
    불변성 여부를 구분할 때의 변경 가능성의 대상은 데이터 영역 메모리다. 기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값이다.    
    (변수와 상수를 구분 짓는 변경 가능성의 대상은 변수 영역 메모리이다.)  
    ```javascript
     var a = 'abc';
     a = a+'def;
     
     var b = 5;
     var c = 5;
     b =7;
    ```
    변수 a에 문자열 'abc'를 할당했다가 뒤에 'def'를 추가하면 기존의 'abc'가 'abcdef'로 바뀌는 것이 아니라 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장한다. 'abc'와 'abcdef'는 완전히 별개의 데이터이다.  
    
    변수 b에 5를 할당할 때는 일단 데이터 영역에서 5를 찾고, 없으면 데이터 공간을 하나 만들어 저장한다. 그리고 그 주소를 b에 저장한다.  
    변수 c에 5를 할당할 때는 데이터 영역에 있는 5를 찾고, 그 주소를 c에 할당한다.  
    변수 b의 값을 7로 바꾸자 할 때는 기존에 저장했던 7을 찾아서 있으면 재활용하고, 없으면 새로 만들어 b에 저장한다.  
    결국 5와 7 모두 다른 값으로 변경할 수 없다.  
    
    위와 같이 문자열, 숫자 값은 한 번 만든 값을 바꿀 수 없고, 다른 값으로 변경할 수 없다. 한 번 만들어진 값을 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.  
    
  - 가변값  
    참조형 데이터는 가변값인 경우도 있고, 아예 불변값으로 활용하는 방안도 있다.  
      
    우선 참조형 데이터를 변수에 할당하는 과정부터 살펴보자.   
    ```javscript
     var obj = {
      a: 1,
      b: 'bbb'
     }
    ```
    <table>
     <tr>
      <th rowspan = "2">변수 영역</th>
      <th>주소</th>
      <td>1001</td>
      <td>1002</td>
      <td>1003</td>
      <td>1004</td>
      <td>....</td>
     </tr>
     <tr>
      <th>데이터</th>
      <td></td>
      <td>이름: obj <br> 값 :@5001</td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <th rowspan = "2">데이터 영역</th>
      <th>주소</th>
      <td>5001</td>
      <td>5002</td>
      <td>5003</td>
      <td>5004</td>
      <td>...</td>
     </tr>
     <tr>
      <th>데이터</th>
      <td>@7013~?</td>
      <td></td>
      <td>1</td>
      <td>'bbb'</td>
      <td></td>
     </tr>
    </table>
   
    <table>
      <tr>
       <th rowspan = "2">객체 @5001의 <br> 변수 영역</th>
       <th>주소</th>
       <td>7013</td>
       <td>7014</td>
       <td>7015</td>
       <td>7016</td>
       <td>...</td>
      </tr>
     <tr>
       <th>데이터</th>
       <td>이름 : a <br> 값 : @5003</td>
       <td>이름 : b <br> 값 : @5004</td>
       <td></td>
       <td></td>
       <td></td>
      </tr>
    </table>
   <!--20210209 -->
   1. 컴퓨터는 우선 변수 영역의 빈 공간(@1002)를 확보하고, 그 주소의 이름을 obj로 지정한다.  
   2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 이 그룹 내부의 프로퍼티를 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(@7103~?)를 @5001에 저장한다.
   3. @7103, @7104에 각각 a와 b라는 프로퍼티 이름을 지정한다.  
   4. 데이터 영역에서 숫자 1을 검색한 후, 검색 결과가 없으면 임의로 데이터 영역에 저장하고(@5003), 이 주소를 @7103에 저장한다.  
        문자열 'bbb'도 @5004에 저장하고, 이 주소를 @7104에 저장한다.  
  
   기본형 데이터와의 차이는 객체의 변수 영역이 별도로 존재한다는 점이다. 그림을 보면 객체가 별도로 할애한 영역은 변수 영역일 뿐 데이터 영역은 기존의 메모리 공간을 그대로 활용하고 있다.  
   데이터 영역에 저장된 값은 모두 불변 값이다. 하지만 변수에는 다른 값을 얼마든지 대입할 수 있다. 이 부분 때문에 흔히 참조형 데이터는 가변값이라고 한다. 예제로 확인해보자.  
   
   ```javascript
    var obj = {
     a:1,
     b: 'bbb'
    };
    obj.a = 2;
   ```
   
   <table>
     <tr>
      <th rowspan = "2">변수 영역</th>
      <th>주소</th>
      <td>1001</td>
      <td>1002</td>
      <td>1003</td>
      <td>1004</td>
      <td>1005</td>
      <td>....</td>
     </tr>
     <tr>
      <th>데이터</th>
      <td></td>
      <td>이름: obj <br> 값 :@5001</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <th rowspan = "2">데이터 영역</th>
      <th>주소</th>
      <td>5001</td>
      <td>5002</td>
      <td>5003</td>
      <td>5004</td>
      <td>5005</td>
      <td>...</td>
     </tr>
     <tr>
      <th>데이터</th>
      <td>@7013~?</td>
      <td></td>
      <td>1</td>
      <td>'bbb'</td>
      <td>2</td>
      <td></td>
     </tr>
    </table>
   
   <table>
      <tr>
       <th rowspan = "2">객체 @5001의 <br> 변수 영역</th>
       <th>주소</th>
       <td>7013</td>
       <td>7014</td>
       <td>7015</td>
       <td>7016</td>
       <td>7017</td>
       <td>...</td>
      </tr>
     <tr>
       <th>데이터</th>
       <td>이름 : a <br> 값 : <del>@5003</del><br>@5005</td>
       <td>이름 : b <br> 값 : @5004</td>
       <td></td>
       <td></td>
       <td></td>
       <td></td>
      </tr>
    </table>
    
   a 프로퍼티에 2를 대입하게 되면, @5003을 참조하는 변수가 하나도 없게 된다.  
   어떤 데이터에 자신의 주소를 참조하는 변수의 개수를 참조 카운트라고 하는데, a 프로퍼티 값이 2로 변하면서 @5003의 참조 카운트는 0이 된다.  
   참조 카운트가 0인 메모리 주소를 가비지 컬렉터의 수거 대상이된다. 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.  
   <!--20210209 기록 마침-->
   
   <!--20210215 기록 시작-->
  - 변수 복사 비교  
   ```javascript
    var a = 10; 
    var b = a;
    
    var obj1 = {c:10, d: 'dd'};
    var obj2 = obj1;
   ```
   <table>
     <tr>
      <th rowspan = "2">변수 영역</th>
      <th>주소</th>
      <td>1001</td>
      <td>1002</td>
      <td>1003</td>
      <td>1004</td>
      <td>....</td>
     </tr>
     <tr>
      <th>데이터</th>
      <td>이름: a <br> 값 :@5001</td>
      <td>이름: b <br> 값 :@5001</td>
      <td>이름: obj1 <br> 값 :@5002</td>
      <td>이름: obj2 <br> 값 :@5002</td>
      <td></td>
     </tr>
     <tr>
      <th rowspan = "2">데이터 영역</th>
      <th>주소</th>
      <td>5001</td>
      <td>5002</td>
      <td>5003</td>
      <td>5004</td>
      <td>...</td>
     </tr>
     <tr>
      <th>데이터</th>
      <td>10</td>
      <td>@7013~?</td>
      <td>'dd'</td>
      <td></td>
      <td></td>
     </tr>
    </table>
   
   <table>
      <tr>
       <th rowspan = "2">객체 @5002의 <br> 변수 영역</th>
       <th>주소</th>
       <td>7013</td>
       <td>7014</td>
       <td>7015</td>
       <td>7016</td>
       <td>7017</td>
       <td>...</td>
      </tr>
     <tr>
       <th>데이터</th>
       <td>이름 : c <br> 값 : @5001</td>
       <td>이름 : d <br> 값 : @5003</td>
       <td></td>
       <td></td>
       <td></td>
       <td></td>
      </tr>
    </table>
   
   변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일함.  
   하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에서 큰 차이가 발생하게 된다
   
   변수 복사 이후 값 변경 결과를 비교해보자  
   ```javascript
   
    var a = 10; 
    var b = a;
    
    var obj1 = {c:10, d: 'dd'};
    var obj2 = obj1;
    
    b = 15;
    obj2.c = 20;
   
   ```
   
   변수 b에 15를 할당하는 과정에서는 15가 아직 없으므로 @5004에 저장하고, 그 주소를 든 채로 변수 영역에서 식별자가 b인 주소를 찾는다.  
   @1002의 값이 @5004로 변경된다.  
   
   obj2 객체의 프로퍼티 c에 20을 할당하는 과정에서는 20이 아직 없으므로 @5005에 저장하고, 그 주소를 든 채로 변수 영역에서 obj2를 찾는다(@1004).
   그리고 obj2의 값인 @5002가 가리키는 변수 영역에서 다시 c를 찾아(@7013) 그곳에 @5005를 대입한다.  

   <table>
     <tr>
      <th rowspan = "2">변수 영역</th>
      <th>주소</th>
      <td>1001</td>
      <td>1002</td>
      <td>1003</td>
      <td>1004</td>
      <td>1005</td>
      <td>....</td>
     </tr>
     <tr>
      <th>데이터</th>
      <td>이름: a <br> 값 :@5001</td>
      <td>이름: b <br> 값 :@5004</td>
      <td>이름: obj1 <br> 값 :@5002</td>
      <td>이름: obj2 <br> 값 :@5002</td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <th rowspan = "2">데이터 영역</th>
      <th>주소</th>
      <td>5001</td>
      <td>5002</td>
      <td>5003</td>
      <td>5004</td>
      <td>5005</td>
      <td>...</td>
     </tr>
     <tr>
      <th>데이터</th>
      <td>10</td>
      <td>@7013~?</td>
      <td>'dd'</td>
      <td>15</td>
      <td>20</td>
      <td></td>
     </tr>
    </table>
   
   <table>
      <tr>
       <th rowspan = "2">객체 @5002의 <br> 변수 영역</th>
       <th>주소</th>
       <td>7013</td>
       <td>7014</td>
       <td>7015</td>
       <td>7016</td>
       <td>7017</td>
       <td>...</td>
      </tr>
     <tr>
       <th>데이터</th>
       <td>이름 : c <br> 값 : @5005</td>
       <td>이름 : d <br> 값 : @5003</td>
       <td></td>
       <td></td>
       <td></td>
       <td></td>
      </tr>
    </table>
    
   기본형 데이터를 복사한 변수 b의 값을 바꿨더니 @1002의 값이 달라진 반면, 참조형 데이터를 복사한 변수 obj2의 프로퍼티를 바꾸었더니 @1004의 값은 바뀌지 않았다.  
   변수 a와 b는 서로 다른 주소를 바라보게 되었지만, 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있다.  
   
   <!--20210215 기록 마침 기본형 데이터와 참조형 데이터의 복사 과정에 대해 알게되었다.-->
  <!--20210310 기록 시작-->
   b의 경우와 마찬가지로 obj2에도 새로운 객체를 할당해보자. 
  ```javascript
   
    var a = 10; 
    var b = a;
    
    var obj1 = {c:10, d: 'dd'};
    var obj2 = obj1;
    
    b = 15;
    obj2 = {c:20, d:'dd'};
   
   ```
   <br>
   
   <table>
     <tr>
      <th rowspan = "2">변수 영역</th>
      <th>주소</th>
      <td>1001</td>
      <td>1002</td>
      <td>1003</td>
      <td>1004</td>
      <td>1005</td>
      <td>1006</td>
      <td>....</td>
     </tr>
     <tr>
      <th>데이터</th>
      <td>이름: a <br> 값 :@5001</td>
      <td>이름: b <br> 값 :@5004</td>
      <td>이름: obj1 <br> 값 :@5002</td>
      <td>이름: obj2 <br> 값 :@5006</td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <th rowspan = "2">데이터 영역</th>
      <th>주소</th>
      <td>5001</td>
      <td>5002</td>
      <td>5003</td>
      <td>5004</td>
      <td>5005</td>
      <td>5006</td>
      <td>...</td>
     </tr>
     <tr>
      <th>데이터</th>
      <td>10</td>
      <td>@7013~?</td>
      <td>'dd'</td>
      <td>15</td>
      <td>20</td>
      <td>@8204~?</td>
      <td></td>
     </tr>
    </table>
   
   <table>
      <tr>
       <th rowspan = "2">객체 @5002의 <br> 변수 영역</th>
       <th>주소</th>
       <td>7013</td>
       <td>7014</td>
       <td>...</td>
       <td>8204</td>
       <td>8205</td>
       <td>...</td>
      </tr>
     <tr>
       <th>데이터</th>
       <td>이름 : c <br> 값 : @5005</td>
       <td>이름 : d <br> 값 : @5003</td>
       <td></td>
       <td>이름 : c <br> 값 : @5005</td>
       <td>이름 : d <br> 값 : @5003</td>
       <td></td>
      </tr>
    </table>
    
   obj2에 새로운 객체를 할당하면 데이터 영역의 새로운 공간에 새 객체가 저장되고, 그 주소를 변수 영역의 obj2에 저장한다. 겍체에 대한 변경임에도 값이 달라졌다.  
   즉, 참조형 데이터가 '가변값'잉라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부 프로퍼티를 변경할 때만 성립된다.  
    
   - 불변 객체  
     값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우 불변 객체가 필요하다.  
     
