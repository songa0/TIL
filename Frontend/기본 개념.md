# 렌더링
  ✅ 렌더링  
  ✅ 렌더링 과정  
  ✅ SSR과 CSR  
  
  ### 렌더링 
  HTML, CSS, JavaScript 등 개발자가 작성한 문서들을 브라우저가 화면에 그려주는 동작

  ### 렌더링 과정  
  **Scripting** : HTML을 파싱하여 DOM 트리를 만든다  
                  CSS를 파싱하여 CSSOM 트리를 만든다  
  **Rendering** : DOM과 CSSOM을 결합하여 렌더링 트리를 만든다   
  **Layout** : 렌더링 트리에서 각 노드의 크기와 위치를 계산한다  
  **Painting** : 계산해둔 것을 적절하게 나눠서 이미지(비트맵)를 준비해둔다. 수정 사항이 나오면 해당 레이어만 수정하면 되기 때문 - 성능 개선을 위함 
             will-change 라는 속성 값을 주면 layer로 나눠진다   
  **Composition** : 레이어를 브라우저에 표기한다  
  
  성능을 개선하기 위해서는 paint 횟수를 줄여야한다.  
  
  ### SSR와 CSR  
  📌 **Server-side Rendering 이란?**  
  : 서버에서 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식  
    
   **장점**  
    로딩 속도가 빠르다.   
    SEO(Search Engine Optimization)가 많은 양의 웹 콘텐츠 정보를 수집하게 되므로, 검색 사이트 상위 노출에 유리하다.  
    (검색 엔진 봇이 웹 사이트 정보를 수집하고자 Server에 요청하면, Server는 콘텐츠 정보를 포함한 html을 제공하므로 검색엔진 봇은 많은 정보를 수집할 수 있게 된다.)    
    **단점**  
    페이지를 이동할 때 깜빡임 현상이 생긴다.  
    서버 부담이 발생한다.  
  
  📌 **Client-side Rendering 이란?**  
   : js 엔진이 동적으로 html element를 생성한 뒤, root element에 추가하여 웹 콘텐츠를 만드는 방식   
     (SPA에서 사용함)  
   
   **장점**  
   서버 부담을 줄일 수 있다.  
   **단점**  
   웹 페이지 초기 로딩 지연시간이 발생한다.  
   (서비스에서 필요한 데이터를 클라이언트에서 추가로 요청해서 재구성해야하기 때문)  
   SEO가 웹 콘텐츠 정보를 수집하지 못해, 검색사이트 상위 노출에 불리하다.  
   
<br/>  

# Event loop  
  ✅ 프로세스와 쓰레드  
  ✅ 자바스크립트 런타임 환경  
  ✅ 브라우저 런타임 환경  
  
  ### 프로세스와 쓰레드  
   📌**프로세스**  
   운영체제 위에서 연속적으로 실행되고 있는 프로그램   
   code, stack(호출 정보), heap(동적으로 할당된 변수 저장), data(전역 변수 저장)  
   📌**쓰레드**  
   한 프로세스 안에서 여러 개가 동작할 수 있다.  
   쓰레드 마다 stack이 할당되어 있다. code, heap, data는 다른 쓰레드와 공유함    
   JS는 싱글쓰레드 언어이다.  
   
   ### 자바스크립트 런타임 환경   
   📌**Memory Heap**  
   데이터 생성하면 모두 heap에 저장된다.  
   📌**Stack**  
   함수를 실행 순서에 따라 담아놓는 자료구조  
   
   ### 브라우저 런타임 환경과 Event loop   
   Web API를 이용하여 브라우저의 멀티스레딩을 사용할 수 있다.  
   
   ### Event loop의 역할   
   Call Stack과 Task Queue를 관찰하고 있다가, Call Stack이 비어있으면 Task Queue에 있는 아이템을 Call Stack에 넣어주어 실행하게 한다.    
   <img src="https://user-images.githubusercontent.com/17793440/137628351-bcafebff-5b9b-4e1b-9c63-a9d6879a0626.png" width=750px/>    
   

   **Render**  
   변형한 코드가 주기적으로 업데이트 되기 위해 주기적으로 호출되는 순서   
   Request Animation Frame -> Render Tree -> Layout -> Paint   
   Request Animation Frame 부르면 이때 등록된 콜백은 큐에 차곡차곡 채워진다.   
   브라우저마다 정해진 시간마다 주기적으로 Render 트리를 업데이트 한다. (따라서 주기가 돌아오지 않았을 때는 이벤트 루프가 render 쪽을 들르지 않음)  

   **Microtask Queue**  
   프로미스에 등록된 콜백, mutation observer의 콜백이 들어온다.     
   이벤트 루프는 microtask queue에 아이템이 없을 때까지 아이템을 call stack으로 옮기는 작업을 계속함      

   **Task Queue**  
   대부분의 콜백 함수들이 들어온다.      
   이벤트 루프는 한 번에 하나의 아이템만 call stack에 넣고 다시 순회함    
  
   
<br/>     
   
   
# ES6에 추가된 문법  
  ✅ 화살표 함수  
  ✅ Promise  
  ✅ let, const  
  ✅ generators  
 
 ### 화살표 함수   
   📌 **화살표 함수** 
     : 함수 표현식을 간편하게 쓸 수 있는 문법  
     제한 사항  
     this에 대한 바인딩이 없고, methods로 사용될 수 없다. 
      : 실행 컨텍스트 생성 시, this를 바인딩하지 않는다.  
     call, apply, bind methods를 이용할 수 없다.  
     생성자로 사용할 수 없다.  
     yield를 화살표 함수 내에서 사용할 수 없다.  
     
  📌 **call, apply, bind 함수**  
     : this를 바인딩하는 것을 도와주는 함수  
     **call**  
     주어진 this 값 및 각각 전달된 **인수**와 함께 함수를 호출한다.  
     **apply**  
     주어진 this 값과 **배열** (또는 유사 배열 객체) 로 제공되는 arguments 로 함수를 호출한다.  
     **bind**  
     새로운 함수를 생성한다. 첫 인자로는 this 키워드를 설정하고, 이어지는 인자들은 바인드된 함수의 인수에 들어간다.       
 
 ### Promise              
   📌 비동기 통신이란?  
   
   📌 콜백지옥  
   
   📌 Promise  
      등장한 이유  
   📌 async, await  
   
 ### let, const  
   📌 let, const, var
   
   📌 호이스팅이란?  
   
   📌 왜 var만 호이스팅 대상이 되는가?  
   
 ### generators  
 
  
# Local Storage, Session Storage, Cookie  
  ✅ Local Storage  
  ✅ Session Storage   
  ✅ Cookie 


2. React 훅의 적용 조건
3. local storage, session storage, cookie  
   - 아이디 저장 같은 경우 왜 cookie를 사용했는지
4. webpack, babel, 폴리필 
5. package.json 역할  
   - dependency 란?
7. rest API란?
8. REACT vs Vue 
10. http 통신 메소드
11. 에러 코드 (200, 404 ..)
15. typescript란
16. 클로저란 + 언제 쓰는지
17. 싱글스레드에서 어떻게 비동기 처리가 이루어지는가
